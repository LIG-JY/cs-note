# Direct Execution

## CPU 가상화 초식

CPU time sharing:
각 프로세스가 잠깐씩 CPU를 사용하는 개념

## CPU 가상화 실현의 challenge

1. Performance
2. Control
    - 제어가 없으면, 한 프로세스가 CPU를 무한정 점유할 수 있음.

## 기본적인 접근법: Limited Direction Execution (A.K.A LDE Protocol)

- 직접실행 + 제어

### 직접실행(Direction Execution)

말 그대로 프로그램이 CPU 상에서 직접 실행

구체적인 과정(시간순)은 아래와 같음

[OS Role]

1. 프로세스 항목 생성 후 프로세스 목록에 항목 추가
2. 프로그램을 위한 메모리 할당
3. 메모리에 프로그램 로드 (from disk to memory)
4. 스택 setup
    - main함수의 인자 argc, argv를 스택에 로드
5. 레지스터 비우기

---
[Program Role]

6. main 함수 실행 (asm `call`)
7. 프로그램 실행 (asm `return`)

---
[OS Role]

8. 메모리 해제
9. 프로세스 엔트리 삭제(process list에서 제거)

### 제한이 없을 때 예상되는 문제

- 프로그램이 허용되지 않은 동작을 한다면?
    - 즉 시스템 리소스에 마음대로 접근한다면?
- 다른 프로그램을 동시에 실행하고 싶으면?
    - time sharing을 어떻게 구현할 것인가?

## Direction Execution's challenge 1: Restricted Operation

- Restricted Operations:
    - 말 그대로 운영체제에서 제한하는 연산, I/O 요청과 같은 시스템 리소스에 대한 접근을 말함

- 문제점:
    - 프로세스를 CPU에서 직접 실행할 때 Restricted Operation을 수행해야한다면 어떻게 제어해야할까?
        - 제어 없이 Restricted Operation을 허용하면 바람직한 시스템이라고 볼 수 없음
        - Ex) 권한 검사를 하지 않는 파일시스템을 만들었다고 가정하면 프로세스 전체 디스크에 마음대로 접근가능함..

- 해결:
    - 프로세서(CPU)의 상태를 구분하는 방법
        - User mode
            - 유저 모드일 때 프로세스는 I/O 요청과 같은 제한된 연산을 할 수 없음
            - 요청한다면 예외가 발생하고 OS는 프로세스를 죽여버림
        - Kernel mode
            - 시스템 리소스에 접근가능한 특권을 가짐
    - 사용자 프로세스가 두 모드를 전환하기 위해서 OS는 **system call**을 지원함
        - 커널은 특정 기능 부분을 제공
            - 파일 시스템 접근
            - 프로세스 생성 및 파괴
            - 다른 프로세스와 통신
            - 추가 메모리 할당...

- 일반적인 시나리오:
    - 프로세스가 시스템 콜을 호출하게 되면  **trap** 명령어를 통해 프로세서는 커널 모드로 진입하게 됨
        - trap 명령어는 C Library 시스템 콜 함수에 포함되어 있음
        - [참고](#aside-why-system-calls-look-like-procedure-calls)
    - 필요한 작업 수행
        - 이를 위해서 하드웨어에서 시스템 콜을 지원해야함. 하드웨어는 커널을 통해서 시스템콜을 사용자에게 지원함
        - 커널이 사용자와 하드웨어 사이의 인터페이스 역할을 한다는 것을 재확인
    - 작업이 완료되면 운영체제는 **return-from-trap** 명령어를 호출해 유저 모드로 돌아옴 그리고 호출자로 돌아감

- 이 시나리오에서 하드웨어(프로세서)는 **trap** 명령어를 실행하기 전 호출한 프로세스의 상태를 저장하는 작업이 필요함
    - 이 작업이 없으면 OS가 **return-from-trap** 명령어를 호출했을 때 호출자로 돌아올 수 없음
    - 여기서 필요한 것이 [Kernel-Stack](#per-process-kernel-stack)

- 이 시나리오에서 추가적으로 생각해볼 점은 **trap** 명령어의 동작임
    - **trap** 명령어는 일반화되어 여러 절차를 포함하는 명령어임
        - [참고](https://en.wikipedia.org/wiki/Interrupt)
    - 프로세스가 **trap** 명령어를 실행하게 되면 구체적으로 OS의 어떤 함수를 호출해야하는지 알아야함
        - 즉 분기가 필요함
    - 하지만 이 때문에 프로세스에게 직접적으로 커널 내부의 함수의 주소를 노출하면 안 됨
    - 대신 [Trap-table](#trap-table)을 통해 간접적으로 노출함

### Per-process Kernel stack

- **trap**이 발생하면 프로세서(CPU)는 커널 모드로 전환됨
- 이 때 유저 모드의 프로그램 상태를 저장해야함, 그렇게 해야 **return-from-trap** 후 유저 모드가 중단되었던 명령어부터 실행할 수 있음
    - 프로그램의 상태는 일반적으로 레지스터로 관리함
        - 프로그램 카운터, 플래그 등등
    - 레지스터의 값을 **Kernel stack**에 저장
        - 유저 모드일 때 사용하는 스택 메모리와 별개
        - 프로세스마다 할당됨
- 사실 원리는 함수에서 다른 함수를 호출하는 콜 스택 개념과 다를 바 없음

### Trap table

1. 커널이 trap-table을 설정
    - 시스템 초기화(boot time) 과정에서 설정
    - trap 매커니즘이 필요한 시스템 콜, 하드웨어 인터럽트, 예외에 대한 이벤트 핸들러의 메모리 주소를 매핑
    - trap table은 커널이 보호하는 메모리 영역에 올라감. 커널 모드일 때는 이 테이블에 접근할 수 있음
    - 부팅 시 CPU는 커널 모드
2. CPU는 시스템 콜이 발생하면 trap 명령어에 따라 커널 모드로 전환하고 이 테이블을 참조해 핸들러를 호출함

여기에도 제어(control)의 개념이 포함됨. 시스템 콜이 아닌 일반적인 프로시저 콜은 `call`같은 어셈블리어를 통해 코드 섹션에 함수의 주소를 호출하는 방식으로 구현됨. 만약 `call`로 아무 메모리의
영역에 접근한다면 문제가 발생함 이를 방지하기 위해 OS는 trap이 발생하면 trap-table을 통해 특정 핸들러의 주소만 노출함.

핵심은 임의의 메모리(특히 커널이 관리하는 영역)에 접근하면 안 되기 때문에 어떻게 특정 구역의 코드만 노출할 것인가를 trap-table로 해결했다는 것

- Trap table 사용 시나리오
    1. 프로세스(프로세서는 유저모드)가 시스템 콜 호출
    2. trap 명령어 실행
    3. 커널 스택에 현재 레지스터 값들 push
    4. 프로세서는 커널 모드로 전환됨
    5. 프로세서는 트랩 테이블을 참조해 트랩 핸들러 호출
        - 보통 CPU에 하드웨어적으로 트랩을 처리하는 명령어를 내포함
    6. 커널은 트랩 핸들러에 따라 작업 수행
    7. 작업이 끝나고 OS는 return-from-trap 호출

### System call number

- 프로세서가 트랩 테이블을 참조할 때 사용하는 것이 **System-call-number**
    - 유저 프로세스가 시스템 콜을 호출하면 C library에서 시스템 콜 함수의 인자와 **System-call-number**을 스택이나 레지스터에 저장함
    - 이를 통해 CPU는 트랩 테이블에서 트랩 핸들러를 찾아 jump할 수 있음
        - 배열의 인덱스, 테이블의 key-value같은 동작
    - 트랩 핸들러 내부에서 **System-call-number**을 검증하는 과정도 거침
        - 트랩 핸들러는 OS의 코드 블럭임을 잊지말자

이런 간접참조(indirection)을 통해서 직접적으로 커널의 주소를 노출하지 않게 됨 (제어, 보안 개념)

## ASIDE: WHY SYSTEM CALLS LOOK LIKE PROCEDURE CALLS

- Procedure call
    - C의 전형적인 함수 호출 방식
    - `int result = add(a, b);` 와 같은 방식으로 함수를 호출하고, 반환값을 변수에 저장
    - 이 때 함수의 인자는 스택과 레지스터에 저장되고 스택 프레임이 생성됨

- System call
    - procedure call과 마찬가지로 유저는 C library의 함수를 호출함
    - 시스템 콜에 속하는 이 함수의 구현은 **trap** 명령어를 포함함
        - 이 명령어는 단순하게 어셈블리어 명령어 한 줄이 아니라, 복합적인 과정임
        - C 라이브러리와 커널 간에 규약인 calling convetion에 따라 인자와 [시스템 콜 넘버]()를 스택, 레지스터에 위치
            - 이 정보를 통해 커널이 시스템 콜을 처리함
    - 시스템 콜이 처리되고 커널이 결과를 반환하면, C 라이브러리는 이 결과를 unpack해서 호출한 프로그램에 전달

결론은 C 라이브러리가 인터럽트 어셈블리 코드를 함수들에 포함시켜 구현해 놓음  
C 라이브리의 역할 == 사용자와 운영체제 사이의 인터페이스